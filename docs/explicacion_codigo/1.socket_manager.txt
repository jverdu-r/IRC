***************************************************

#include "socket_manager.h"
#include <iostream>
#include <cstring> // Para memset
#include <cstdlib> // Para exit()

						***

#include "socket_manager.h": Incluye el archivo de encabezado socket_manager.h, que define la clase SocketManager.
#include <iostream>: Incluye la biblioteca de entrada/salida estándar para usar std::cout y std::cerr.
#include <cstring>: Incluye la biblioteca de cadenas de caracteres para usar memset.
#include <cstdlib>: Incluye la biblioteca estándar de C para usar exit.

***************************************************

#################   SocketManager    #################
SocketManager::SocketManager(int port) {
    // 1. Crear el socket del servidor
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == -1) {
        std::cerr << "Error al crear el socket del servidor." << std::endl;
        exit(1);
    }

						***


SocketManager::SocketManager(int port): Constructor de la clase SocketManager. Toma el número de puerto como argumento.
server_fd = socket(AF_INET, SOCK_STREAM, 0): Crea un socket del servidor usando la función socket.
AF_INET: Indica que se usará IPv4.
SOCK_STREAM: Indica que se usará TCP.
0: Indica que se usará el protocolo predeterminado.
if (server_fd == -1): Verifica si hubo un error al crear el socket.
std::cerr << "Error al crear el socket del servidor." << std::endl;: Imprime un mensaje de error en la salida de error estándar.
exit(1): Termina el programa con un código de error.

***************************************************

// 2. Configurar la dirección del servidor
    sockaddr_in server_address;
    memset(&server_address, 0, sizeof(server_address));
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = INADDR_ANY;
    server_address.sin_port = htons(port);

						***

sockaddr_in server_address;: Declara una estructura sockaddr_in para almacenar la dirección del servidor.
memset(&server_address, 0, sizeof(server_address)): Inicializa la estructura server_address con ceros.
server_address.sin_family = AF_INET;: Establece la familia de direcciones a IPv4.
server_address.sin_addr.s_addr = INADDR_ANY;: Establece la dirección IP del servidor para aceptar conexiones en cualquier interfaz.
server_address.sin_port = htons(port);: Establece el número de puerto del servidor. htons convierte el número de puerto a formato de red.

***************************************************

// 3. Asociar el socket a la dirección del servidor
	int reuse = 1;
	if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse)) == -1) {
		std::cerr << "Error al configurar SO_REUSEADDR." << std::endl;
		exit(1);
	}
    if (bind(server_fd, (sockaddr*)&server_address, sizeof(server_address)) == -1) {
        std::cerr << "Error al asociar el socket a la dirección." << std::endl;
        exit(1);
    }

						***
if (setsockopt(...) esta linea permite usar un socket que este en estado TIME_WAIT. es util para reiniciar el servidor rapidamente. 
bind(server_fd, (sockaddr*)&server_address, sizeof(server_address)): Asocia el socket del servidor a la dirección del servidor.
if (bind(...) == -1): Verifica si hubo un error al asociar el socket.
std::cerr << "Error al asociar el socket a la dirección." << std::endl;: Imprime un mensaje de error.
exit(1): Termina el programa.

***************************************************

   // 4. Poner el socket en modo de escucha
    if (listen(server_fd, 5) == -1) {
        std::cerr << "Error al poner el socket en modo de escucha." << std::endl;
        exit(1);
    }

						***

listen(server_fd, 5): Pone el socket del servidor en modo de escucha, permitiendo hasta 5 conexiones en cola.
if (listen(...) == -1): Verifica si hubo un error.
std::cerr << "Error al poner el socket en modo de escucha." << std::endl;: Imprime un mensaje de error.
exit(1): Termina el programa.

***************************************************

 // 5. Crear la instancia de epoll
    epoll_fd = epoll_create1(0);
    if (epoll_fd == -1) {
        std::cerr << "Error al crear la instancia de epoll." << std::endl;
        exit(1);
    }

						***

epoll_fd = epoll_create1(0): Crea una instancia de epoll.
if (epoll_fd == -1): Verifica si hubo un error.
std::cerr << "Error al crear la instancia de epoll." << std::endl;: Imprime un mensaje de error.
exit(1): Termina el programa.

***************************************************

 // 6. Agregar el socket del servidor a epoll
    epoll_event event;
    event.events = EPOLLIN;
    event.data.fd = server_fd;
    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, server_fd, &event) == -1) {
        std::cerr << "Error al agregar el socket del servidor a epoll." << std::endl;
        exit(1);
    }

						***

epoll_event event;: Declara una estructura epoll_event para configurar el evento de epoll.
event.events = EPOLLIN;: Establece el evento a EPOLLIN, indicando que se debe esperar a que haya datos disponibles para leer.
event.data.fd = server_fd;: Establece el descriptor de archivo del socket del servidor.
epoll_ctl(epoll_fd, EPOLL_CTL_ADD, server_fd, &event): Agrega el socket del servidor a epoll.
if (epoll_ctl(...) == -1): Verifica si hubo un error.
std::cerr << "Error al agregar el socket del servidor a epoll." << std::endl;: Imprime un mensaje de error.
exit(1): Termina el programa.

***************************************************

    std::cout << "Servidor escuchando en el puerto " << port << "..." << std::endl;
}

						***

std::cout << "Servidor escuchando en el puerto " << port << "..." << std::endl;: Imprime un mensaje indicando que el servidor está escuchando en el puerto especificado.

***************************************************

SocketManager::~SocketManager() {
    close(epoll_fd);
    close(server_fd);
}

						***

SocketManager::~SocketManager(): Destructor de la clase SocketManager.
close(epoll_fd): Cierra la instancia de epoll.
close(server_fd): Cierra el socket del servidor.

***************************************************

#################   run    #################

void SocketManager::run() {
    epoll_event events[MAX_EVENTS];
    while (true) {
        int num_events = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
        if (num_events == -1) {
            std::cerr << "Error en epoll_wait." << std::endl;
            continue;
        }

        for (int i = 0; i < num_events; ++i) {
            if (events[i].data.fd == server_fd) {
                acceptConnection();
            } else {
                handleClientEvent(events[i].data.fd);
            }
        }
    }
}

						***

void SocketManager::run(): Función principal del bucle del servidor.
epoll_event events[MAX_EVENTS];: Declara un array de estructuras epoll_event para almacenar los eventos devueltos por epoll_wait.
while (true): Bucle infinito del servidor.
**`int num_events = ep

***************************************************

#################   acceptConnection    #################

void SocketManager::acceptConnection() {
    sockaddr_in client_address;
    socklen_t client_address_len = sizeof(client_address);
    int client_fd = accept(server_fd, (sockaddr*)&client_address, &client_address_len);
    if (client_fd == -1) {
        std::cerr << "Error al aceptar la conexión." << std::endl;
        return;
    }

						***

void SocketManager::acceptConnection(): Esta función se llama cuando epoll detecta un evento EPOLLIN en el socket del servidor, lo que indica que hay una nueva conexión entrante.
sockaddr_in client_address;: Declara una estructura sockaddr_in para almacenar la dirección del cliente.
socklen_t client_address_len = sizeof(client_address);: Obtiene la longitud de la estructura client_address.
int client_fd = accept(server_fd, (sockaddr*)&client_address, &client_address_len);: Acepta la conexión entrante y obtiene el descriptor de archivo del socket del cliente (client_fd).
if (client_fd == -1): Verifica si hubo un error al aceptar la conexión.
std::cerr << "Error al aceptar la conexión." << std::endl;: Imprime un mensaje de error en la salida de error estándar.
return;: Sale de la función si hubo un error.

***************************************************

// Configurar el socket del cliente como no bloqueante
    fcntl(client_fd, F_SETFL, O_NONBLOCK);

						***

fcntl(client_fd, F_SETFL, O_NONBLOCK);: Configura el socket del cliente como no bloqueante. Esto es importante para que las operaciones de lectura y escritura no bloqueen el bucle del servidor.

***************************************************

// Agregar el socket del cliente a epoll
    epoll_event event;
    event.events = EPOLLIN;
    event.data.fd = client_fd;
    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_fd, &event) == -1) {
        std::cerr << "Error al agregar el socket del cliente a epoll." << std::endl;
        close(client_fd);
        return;
    }

						***

epoll_event event;: Declara una estructura epoll_event para configurar el evento de epoll para el socket del cliente.
event.events = EPOLLIN;: Establece el evento a EPOLLIN, indicando que se debe esperar a que haya datos disponibles para leer.
event.data.fd = client_fd;: Establece el descriptor de archivo del socket del cliente.
epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_fd, &event): Agrega el socket del cliente a epoll.
if (epoll_ctl(...) == -1): Verifica si hubo un error al agregar el socket del cliente a epoll.
std::cerr << "Error al agregar el socket del cliente a epoll." << std::endl;: Imprime un mensaje de error.
close(client_fd);: Cierra el socket del cliente si hubo un error.
return;: Sale de la función si hubo un error.

***************************************************

    client_addresses[client_fd] = client_address;
    std::cout << "Nuevo cliente conectado: " << client_fd << std::endl;

}

					***

client_addresses[client_fd] = client_address;: Almacena la dirección del cliente en el mapa client_addresses, usando el descriptor de archivo del cliente como clave.
std::cout << "Nuevo cliente conectado: " << client_fd << std::endl;: Imprime un mensaje indicando que un nuevo cliente se ha conectado.

***************************************************

#################   handleClientEvent    #################

void SocketManager::handleClientEvent(int client_fd) {
    char buffer[1024];
    memset(buffer, 0, sizeof(buffer));
    int bytes_received = recv(client_fd, buffer, sizeof(buffer) - 1, 0);

    std::cout << "bytes_received: " << bytes_received << std::endl;
    std::cout << "buffer: " << buffer << std::endl;

					***

void SocketManager::handleClientEvent(int client_fd): Define la función que maneja los eventos de los clientes conectados.
char buffer[1024];: Declara un buffer de 1024 bytes para almacenar los datos recibidos del cliente.
memset(buffer, 0, sizeof(buffer));: Inicializa el buffer con ceros.
int bytes_received = recv(client_fd, buffer, sizeof(buffer) - 1, 0);: Recibe datos del cliente y los almacena en el buffer.
std::cout << "bytes_received: " << bytes_received << std::endl;: Imprime el número de bytes recibidos para depuración.
std::cout << "buffer: " << buffer << std::endl;: Imprime el contenido del buffer para depuración.

***************************************************

 if (bytes_received == 0) {
        // Cliente envió EOF (Ctrl+D)
        std::cout << "Cliente " << client_fd << " envió EOF." << std::endl;
        if (partial_messages.find(client_fd) != partial_messages.end()) {
            std::cout << "Datos recibidos del cliente " << client_fd << ": " << partial_messages[client_fd];
            broadcastMessage(partial_messages[client_fd], client_fd); // Difundir mensaje parcial
            partial_messages.erase(client_fd);
        } else {
            // No hay mensajes parciales, desconectar
            epoll_ctl(epoll_fd, EPOLL_CTL_DEL, client_fd, NULL);
            close(client_fd);
            client_addresses.erase(client_fd);
        }
    }

					***

if (bytes_received == 0): Verifica si el cliente envió un EOF (Ctrl+D).
std::cout << "Cliente " << client_fd << " envió EOF." << std::endl;: Imprime un mensaje indicando que el cliente envió un EOF.
if (partial_messages.find(client_fd) != partial_messages.end()): Verifica si hay mensajes parciales almacenados para este cliente.
std::cout << "Datos recibidos del cliente " << client_fd << ": " << partial_messages[client_fd];: Imprime los datos parciales recibidos del cliente.
broadcastMessage(partial_messages[client_fd], client_fd);: Difunde el mensaje parcial a todos los demás clientes.
partial_messages.erase(client_fd);: Elimina el mensaje parcial del mapa.
else: Si no hay mensajes parciales, desconecta al cliente.
epoll_ctl(epoll_fd, EPOLL_CTL_DEL, client_fd, NULL);: Elimina el socket del cliente de epoll.
close(client_fd);: Cierra el socket del cliente.
client_addresses.erase(client_fd);: Elimina la dirección del cliente del mapa.

***************************************************

else if (bytes_received < 0) {
        std::cerr << "Error en recv() para cliente " << client_fd << ": " << strerror(errno) << std::endl;
        epoll_ctl(epoll_fd, EPOLL_CTL_DEL, client_fd, NULL);
        close(client_fd);
        client_addresses.erase(client_fd);
        partial_messages.erase(client_fd);
    }

					***

else if (bytes_received < 0): Verifica si hubo un error en la llamada a recv().
std::cerr << "Error en recv() para cliente " << client_fd << ": " << strerror(errno) << std::endl;: Imprime un mensaje de error detallado.
epoll_ctl(epoll_fd, EPOLL_CTL_DEL, client_fd, NULL);: Elimina el socket del cliente de epoll.
close(client_fd);: Cierra el socket del cliente.
client_addresses.erase(client_fd);: Elimina la dirección del cliente del mapa.
partial_messages.erase(client_fd);: Elimina cualquier mensaje parcial almacenado.

***************************************************

 else {
        std::string received_data(buffer, bytes_received);
        std::cout << "received_data: " << received_data << std::endl;

        if (partial_messages.find(client_fd) != partial_messages.end()) {
            std::cout << "partial_messages: " << partial_messages[client_fd] << std::endl;
            received_data = partial_messages[client_fd] + received_data;
            partial_messages.erase(client_fd);
        }

        size_t newline_pos = received_data.find('\n');
        std::cout << "newline_pos: " << newline_pos << std::endl;

        if (newline_pos != std::string::npos) {
            std::cout << "Datos recibidos del cliente " << client_fd << ": " << received_data;
            broadcastMessage(received_data, client_fd); // Difundir mensaje completo
        } else {
            partial_messages[client_fd] = received_data;
        }
    }
}

					***

else: Si se recibieron datos correctamente.
std::string received_data(buffer, bytes_received);: Convierte los datos recibidos a una cadena de caracteres.
std::cout << "received_data: " << received_data << std::endl;: Imprime los datos recibidos para depuración.
if (partial_messages.find(client_fd) != partial_messages.end()): Verifica si hay mensajes parciales almacenados para este cliente.
std::cout << "partial_messages: " << partial_messages[client_fd] << std::endl;: Imprime los datos parciales almacenados.
received_data = partial_messages[client_fd] + received_data;: Concatena los mensajes parciales.
partial_messages.erase(client_fd);: Elimina el mensaje parcial del mapa.
size_t newline_pos = received_data.find('\n');: Busca la posición del salto de línea (\n).
std::cout << "newline_pos: " << newline_pos << std::endl;: Imprime la posición del salto de línea para depuración.
if (newline_pos != std::string::npos): Verifica si se encontró un salto de línea.
std::cout << "Datos recibidos del cliente " << client_fd << ": " << received_data;: Imprime el mensaje completo recibido.
broadcastMessage(received_data, client_fd);: Difunde el mensaje completo a todos los demás clientes.
else: Si no se encontró un salto de línea, almacena el mensaje parcial.
partial_messages[client_fd] = received_data;: Almacena el mensaje parcial en el mapa.

***************************************************

#################   broadcastMessage    #################

void SocketManager::broadcastMessage(const std::string& message, int sender_fd) {
    for (std::map<int, sockaddr_in>::iterator it = client_addresses.begin(); it != client_addresses.end(); ++it) {
        int client_fd = it->first;
        if (client_fd != sender_fd) {
            send(client_fd, message.c_str(), message.length(), 0);
        }
    }
}
					***

void SocketManager::broadcastMessage(const std::string& message, int sender_fd): Define la función que difunde un mensaje a todos los clientes excepto al remitente.
**`for (std::map<int, sockaddr_in>::iterator it = client_addresses.

***************************************************